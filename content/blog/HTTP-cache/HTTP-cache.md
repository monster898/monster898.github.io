---
title: 谈谈HTTP缓存
date: "2021-08-22T14:36:03.284Z"
description: 计算机网络
---
## Why?使用缓存的理由是?
- **减少冗余的网络传输**：当客户端多次请求服务器上同一个资源时，服务器都得多次传回，相同的字节在网络上一遍遍的传输，会消耗网络带宽，降低传输速度，加重web服务器的负载。利用缓存，可以保留第一次服务器响应的副本，后继请求都由缓存处理。
- **缓解网络瓶颈的问题**：很多网络为本地网络客服端提供的带宽比为服务器提供的带宽要宽，客服端会以路径最慢的的网速访问服务器，如果客户端从一个快速局域网的缓存中得到了一份副本，缓存可以提高性能。
- **降低对原始服务器的要求**：服务器可以更快的响应，避免过载（多人同时向服务器请求）的情况出现。
- **降低距离时延**：因为从较远的地方加载页面的速度慢一些。

## 缓存的分类
### (私有)浏览器缓存
单个用户专用的缓存称为私有缓存，通常为web浏览器内建，浏览器缓存拥有用户通过 HTTP 下载的所有文档。这些缓存为浏览过的文档提供向后/向前导航，保存网页，查看源码等功能，可以避免再次向服务器发起多余的请求。它同样可以提供缓存内容的离线浏览。
### 公有代理缓存
共有缓存是特殊的共享代理服务器，被称为缓存代理服务器或者代理缓存，可以被多个用户使用。例如，ISP 或你所在的公司可能会架设一个 web 代理来作为本地网络基础的一部分提供给用户。这样热门的资源就会被重复使用，减少网络拥堵与延迟。

## 缓存的基本处理过程(以HTTP GET请求为例)
1. 接收：缓存从网络中读取抵达的请求报文。
2. 解析：缓存对报文进行解析，提取出URL和各种首部。
3. 查找：缓存查看是否有本地副本可用，本地副本可能储存在内存、本地磁盘，甚至附近的另一台计算机中。如果没有就获取一份副本，并将其保存在本地中。
已缓存对象中包含了服务器响应主体和响应首部，这样就会在缓存命中时返回正确的服务器首部。

4. 新鲜度检测：如果缓存中有服务器文档的副本可用，会查看文档是否足够新鲜(跟我们购买食物查看是否已经过期一样)，如果不是，就进入再验证流程。过期日期是通过特殊的Cache-Control首部和Expires首部决定的，如果没有这两个首部中的任意一个，缓存可以计算一个试探性最大试用期，可以使用任意的算法，例如LM-Factor算法是一个常用的算法。

5. 创建响应：缓存会用新的首部和已缓存的主体来构建一条响应报文。

6. 发送：缓存通过网络将响应发回给客服端。

7. 日志：缓存可选地创建一个日志文件条目来描述这个事务。

## 关键步骤
### 新鲜度检测
判断缓存中的文档(资源)是否过期。服务器通过HTTP/1.0+的Expires首部或者HTTP1.1的Cache-Control:max-age响应首部来指定过期时间，这两个首部做的事情一样，只不过Expires用的是绝对时间，它依赖于计算机时钟的正确设置。所以我们更倾向于使用新的Cache-Control首部。

例子：

Cache-Control:max-age=484200

Cache-Control:public, max-age=31536000, s-maxage=31536000, immutable，其中：
  - public 表示响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存，即使是通常不可缓存的内容。默认private。
  - max-age表示超过31536000s之后缓存被认为过期
  - s-maxage 仅适用于共享缓存(比如各个代理)，私有缓存会忽略它
  - immutable 如果没有超过时间上的过期失效时间，那么服务器端该页面内容将不会改变，这样浏览器就不应该再发送有条件的重新验证请求。简而言之，可以理解为阻止了无意义的条件请求。

Expires: Fri, 05 Jul 2002, 05:00:00 GMT

缓存文档过期之前，缓存可以以任意频率使用这些副本，而无需与服务器联系（除客户端明确要求以外，例如浏览器设置disable cache）
### 服务器再验证
这个流程发生在新鲜度检测之后，如果文档不新鲜则必须进入这个流程。另外文档不新鲜并不代表了服务器一定对此资源发生了更改，而只是意味着到了要进行核对的时间了。

**验证的方法是HTTP条件方法，验证的结果则是内容发生了变化和没有发生变化。**

#### 条件方法
HTTP允许缓存向原始服务器发送一个“条件GET”，当服务器中的对象与缓存的中副本不同时，才回送对象主体。这样就将验证和对象的获取结合成了单个GET，向GET请求中添加特殊的条件首部，如果条件为真，服务器才会返回对象。

最有用的两个条件请求首部`If-Modified-Since`和`IF-None-Match`:

`If-Modified-Since:<date>`:如果在这个日期之后，文档被修改了，则此条件为真，成功执行GET，携带新首部的文档返回给缓存，新首部除了包含其他信息之外，还有一个新的过期日期。如果条件为假，**服务器向客户端返回一个 304 Not Modified报文**，不会返回文档主体。可以和文档的Last-Modified一起使用，原始服务器会将最后的修改日期附加到所提供的文档上去。当缓存文档进行再验证时
`If-Modified-Since:<cached last-modified date>`。服务器与最后修改的时间进行比对。

`IF-None-Match`:这种可以理解为通过标签去再验证，如果这个对象的标签跟服务器原文档的标签一致，则返回304，否则在200 OK响应中返回新的对象和新的标签。这个标签就是实体标签`ETag`,实体标签是附加到对象上的任意标签（引用字符串），他们可能包含了文档的序列号或者版本名，或者是文档内容的校验和其他指纹信息。可以包含多个实体标签，告诉服务器，缓存中已经这些文档版本的副本。

#### 强弱验证类型
--mdn
> 强验证类型
>
>  强验证类型的作用在于确保要比较的资源与其相比较的对象之间每一个字节都相同。对于有些首部来说需要明确指定该验证类型，而对于另外一些来说则是默认值就是强验证类型。强验证类型的要求相当严格，在服务器层面来说可能较难保证。但是它确保了数据在任何时候都没有缺损，有时候则需要以牺牲性能为代价。
>
>  使用 Last-Modified 首部很难为强验证类型提供一个唯一标识。通常这是由 ETag 首部来完成的，该首部可以提供使用 MD5 算法获取的资源（或其衍生品）的散列值。

>  弱验证类型
>
>  弱验证类型与强验证类型不同，因为它会把内容相同的两份文件看做是一样的。例如，使用弱验证类型，一个页面与另外一个页面只是在页脚显示的时间上有所不同，或者是展示的广告不相同，那么就会被认为是相同的。但是在使用强验证的情况下，二者是不同的。构建应用于弱验证类型的标签（etag）体系可能会比较复杂，因为这会涉及到对页面上不同的元素的重要性进行排序，但是会对缓存性能优化相当有帮助。

#### 验证的结果
验证的结果无非就是两种情况，一种是有变化，一种则是无变化。
- 如果再验证显示内容发生了变化，缓存会获取一份新的文档副本存在旧文档的位置，然后将文档发送给客户端。
- 如果再验证显示内容没有发生变化，缓存只需要获取新的首部，包括一个新的过期日期，并对缓存中的首部进行更新就行了。

#### 什么时候使用ETag和Last-Motified
这个要看客服端和服务器的版本

对于HTTP/1.1的源服务器：比较好的做法是同时发送强实体标签和Last-Modified值。

对于客户端：HTTP/1.0使用Last-Motified，HTTP/1.1使用ETag。
如果缓存或服务器收到的请求既带有If-Modified-Since，又带有实体标签首部，那么只有这两个条件都满足时，才能返回304响应。
### 其他
##### 注意Cache-Control: no-store和Cache-control：no-cache的不同。

no-store禁止缓存对响应进行复制，缓存通常会像非缓存代理服务器一样，向客服端转发一条no-store的响应，然后删除对象。

no-cache实际上是可以存储在本地缓存区的，只是在与原始服务器进行新鲜度再验证之前，缓存不能将其提供给客服端使用。这意味着向缓存获取资源时，每次都要进行再验证！如果文档足够新鲜，则每次返回304 Not Motified!

**Http/1.1 中的Pragma：no-cache是兼容HTTP/1.0+，不与HTTP/1.0应用程序交互的话，http1.1应用程序都应该使用Cache-Control：no-cache。**

##### Cache-Control: must-revalidate
当使用了 "must-revalidate" 指令，那就意味着缓存在考虑使用一个陈旧的资源时，必须先验证它的状态，已过期的缓存将不被使用。

### 参考资料
---
《HTTP权威指南》

[关于何时使用实体标签ETag和最后修改时间(Last-modified)的规则](https://blog.csdn.net/tenfyguo/article/details/5892582)

[HTTP缓存](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching)

[Etag](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/ETag)
